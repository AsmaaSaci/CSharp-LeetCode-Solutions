public class Node
{
    private Dictionary<char, Node> _children;
    public Node() 
    {
        _children = new Dictionary<char, Node>();
    }
    public Node InsertChild(char ch) 
    {
        if (!_children.ContainsKey(ch))
            _children.Add(ch, new Node());
        return _children[ch];
    }
    public (bool, Node) Check(char ch) 
    {
        bool exists = _children.ContainsKey(ch);
        return exists ? (true, _children[ch]) : (false, null);
    }

}
public class Trie 
{
    private Node _head;
    public Trie() 
    {
        _head = new Node();
    }
    public void Insert(ReadOnlySpan<char> str) 
    {
        Node t = _head;
        foreach(var charact in str) 
        {
            t = t.InsertChild(charact);
        }
    }
    public Node GetHead() => _head;
}
public class Solution {
    public int MinValidStrings(string[] words, string target) {
        int n = target.Length;
        int[] dp = new int[n + 1];
        for (int i = 0; i <= n; i++) 
        {
            dp[i] = n + 1;
        }
        dp[0] = 0;
        Trie trie =  new Trie();
        for (int i = 0; i < words.Length; i++) {
            trie.Insert(words[i].AsSpan());
        }
        for(int i = 0; i < n; i++) 
        {
            int l = 0;
            Node t = trie.GetHead();
            for(l = 1; i + l <= n; l++) 
            {
                (bool exists, t) = t.Check(target[i+l-1]);
                if (!exists) 
                    break;
                
                dp[i + l] = Math.Min(dp[i] + 1, dp[i + l]);
                
            }
        }
        return dp[n] > n ? -1 : dp[n];
    }
}
