public class Solution {
    private int res = -1;
   // private int[,] adjW;
    private List<int[]>[] adjs;
    private int[] dp;
    private Dictionary<(int, int), int> wDict = new();
 
    public int MaxWeight(int n, int[][] edges, int k, int t) {
        int eSize = edges.Length;
        if( k == 0)
            return k;

        if(eSize == 0)
            return -1;

        adjs = new List<int[]>[n];
        dp = new int[n];
        for(int i = 0; i < n; i++)
        {
            adjs[i] = new List<int[]>();
            dp[i] = -1;
        }

        bool hasAdj = false;
        foreach(int[] cur in edges)
        {
            int from = cur[0], to = cur[1], w = cur[2];

            if(w < t)
            {
                adjs[from].Add([to, w]);
                hasAdj = true;
            }

        }

        if(!hasAdj)
            return -1;

        Queue<int[]> que = new();
        HashSet<string> visited = new();

        for(int i = 0; i < n; i++)
        {
            que.Enqueue([0,i,0]);
            visited.Add("0#"+i.ToString()+"#0");
        }

        while(que.Count > 0)
        {
            var pre = que.Dequeue();
            int preSum = pre[0], node = pre[1], cnt = pre[2];
            foreach(int[] next in adjs[node])
            {
                int nextNode = next[0], nextW = next[1];
                if(preSum + nextW >= t)
                    continue;

                string nextS = (preSum+nextW).ToString() + "#" + nextNode + "#" + (cnt+1).ToString();
                if(visited.Contains(nextS))
                    continue;

                visited.Add(nextS);
                if(cnt == k-1)
                    res = Math.Max(res, preSum+nextW);
                else
                    que.Enqueue([preSum+nextW, nextNode, cnt+1]);
            }
        }

        return res;
    }
}
